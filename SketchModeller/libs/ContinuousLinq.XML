<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ContinuousLinq</name>
    </assembly>
    <members>
        <!-- Badly formed XML comment ignored for member "T:ContinuousLinq.WeakEvents.BaseDictionary`2" -->
        <member name="T:ContinuousLinq.Aggregates.PausedAggregation">
            <summary>
            Usage pattern: When you wish to guard a block of code such that no background re-aggregation of data
            takes place during that block of code, you can enclose your block in a using as follows:
            <code>
            using (PausedAggregation p = new PausedAggregation) { ... guarded code ... }
            </code>
            </summary>
        </member>
        <member name="T:ContinuousLinq.WeakEvents.WeakDictionary`2">
             <summary>
             A generic dictionary, which allows both its keys and values
             to be garbage collected if there are no other references
             to them than from the dictionary itself.
             </summary>
            
             <remarks>
             If either the key or value of a particular entry in the dictionary
             has been collected, then both the key and value become effectively
             unreachable. However, left-over WeakReference objects for the key
             and value will physically remain in the dictionary until
             RemoveCollectedEntries is called. This will lead to a discrepancy
             between the Count property and the number of iterations required
             to visit all of the elements of the dictionary using its
             enumerator or those of the Keys and Values collections. Similarly,
             CopyTo will copy fewer than Count elements in this situation.
             </remarks>
        </member>
        <member name="T:ContinuousLinq.ContinuousCollection`1">
            <summary>
            An observable collection that uses the dispatcher thread to pass all notifications of changes
            up so that changes can be made to a model object by a worker thread.
            This class is taken, almost in it's entirety, from various other implementations of a 
            'thread safe observable collection' available publicly today.
            To support console applications, server apps, and services, dispatching is only 
            done when there is a valid dispatcher available. In all other cases, the notification
            methods are invoked directly.
            </summary>
            <typeparam name="T">Type of element contained within the collection</typeparam>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.#ctor">
            <summary>
            Default constructor, initializes a new list and obtains a reference
            to the dispatcher.
            </summary>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>
            Initializes a new ContinuouseCollection using elements copied from
            the specified list and obtains a reference to the dispatcher.
            </summary>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.NoInvoke">
            <summary>
            If there is no dispatcher, NoInvoke will return true (e.g. Console app)
            If there is a dispatcher, and CheckAccess returns true, NoInvoke will return true
            If there is a dispatcher, and the call was made from a different thread than the
            dispatcher, NoInvoke returns false to indicate that the caller must do
            an Invoke on the dispatcher
            </summary>
            <returns></returns>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.ClearItems">
            <summary>
            Overridden method that does an "items reset" notification on the dispatch thread
            so that bound GUI elements will be aware when this collection is emptied.
            </summary>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.InsertItem(System.Int32,`0)">
            <summary>
            Overridden method that inserts and item into the base collection. Performs a thread-safe
            write to the collection, and dispatches the change notification onto the dispatcher thread
            </summary>
            <param name="index">Index of item being inserted</param>
            <param name="item">Item being inserted</param>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.RemoveItem(System.Int32)">
            <summary>
            Overridden method that performs a thread-safe removal of the item from the collection. Also sends 
            the notification of that removal to the Dispatcher thread.
            </summary>
            <param name="index">Index of item to be removed.</param>
        </member>
        <member name="M:ContinuousLinq.ContinuousCollection`1.SetItem(System.Int32,`0)">
            <summary>
            Overridden method that performs a thread-safe replacement of an item within the collection.
            </summary>
            <param name="index">Index of the item to set</param>
            <param name="item">Item being set</param>
        </member>
        <member name="T:ContinuousLinq.WeakEvents.WeakEventHandler">
            <summary>
            Helper class to add weak handlers to events of type System.EventHandler.
            </summary>
        </member>
        <member name="M:ContinuousLinq.WeakEvents.WeakEventHandler.Register``2(``0,System.Action{``0,System.EventHandler},System.Action{``0,System.EventHandler},``1,System.Action{``1,System.Object,System.EventArgs})">
            <summary>
            Registers an event handler that works with a weak reference to the target object.
            Access to the event and to the real event handler is done through lambda expressions.
            The code holds strong references to these expressions, so they must not capture any
            variables!
            </summary>
            <example>
            <code>
            WeakEventHandler.Register(
            	textDocument,
            	(d, eh) => d.Changed += eh,
            	(d, eh) => d.Changed -= eh,
            	this,
            	(me, sender, args) => me.OnDocumentChanged(sender, args)
            );
            </code>
            </example>
        </member>
        <member name="M:ContinuousLinq.WeakEvents.WeakEventHandler.Deregister">
            <summary>
            Deregisters the event handler.
            </summary>
        </member>
        <member name="T:ContinuousLinq.WeakEvents.WeakEventHandler`1">
            <summary>
            Helper class to add weak handlers to events of type System.EventHandler{A}.
            </summary>
        </member>
        <member name="M:ContinuousLinq.WeakEvents.WeakEventHandler`1.Register``2(``0,System.Action{``0,System.EventHandler{`0}},System.Action{``0,System.EventHandler{`0}},``1,System.Action{``1,System.Object,`0})">
            <summary>
            Registers an event handler that works with a weak reference to the target object.
            Access to the event and to the real event handler is done through lambda expressions.
            The code holds strong references to these expressions, so they must not capture any
            variables!
            </summary>
            <example>
            <code>
            WeakEventHandler&lt;DocumentChangeEventArgs&gt;.Register(
            	textDocument,
            	(d, eh) => d.Changed += eh,
            	(d, eh) => d.Changed -= eh,
            	this,
            	(me, sender, args) => me.OnDocumentChanged(sender, args)
            );
            </code>
            </example>
        </member>
        <member name="T:ContinuousLinq.WeakEvents.WeakPropertyChangedEventHandler">
            <summary>
            Helper class to add weak handlers to events of type PropertyChangedEventHandler.
            </summary>
        </member>
        <member name="T:ContinuousLinq.WeakEvents.WeakNotifyCollectionChangedEventHandler">
            <summary>
            Helper class to add weak handlers to events of type PropertyChangedEventHandler.
            </summary>
        </member>
        <member name="M:ContinuousLinq.ReferenceCountTracker`1.Add(`0)">
            <summary>
            Increments the reference count for the item.  Returns true when refrence count goes from 0 to 1.
            </summary>
        </member>
        <member name="M:ContinuousLinq.ReferenceCountTracker`1.Remove(`0)">
            <summary>
            Decrements the reference count for the item.  Returns true when refrence count goes from 1 to 0.
            </summary>
        </member>
    </members>
</doc>
